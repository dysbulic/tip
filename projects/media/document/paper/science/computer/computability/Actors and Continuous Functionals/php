<?php
$xhtml = preg_match("'application/xhtml\+xml'", $_SERVER['HTTP_ACCEPT']);
if($xhtml) {
  header("Content-type: application/xhtml+xml");
 }
?>
<?php print '<?xml version="1.0" encoding="UTF-8" standalone="yes"?' . ">\n" ?>

<?php if($xhtml): ?>
<!-- "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" -->
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
 "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd"
 [ <!ENTITY mathml  "http://www.w3.org/1998/Math/MathML">
   <!ENTITY hellip  "&#x2026;">
   <!ENTITY bull    "&#x7E6;">
   <!ENTITY deg     "&#xB0;">
   <!ENTITY copy    "&#x9A;">
   <!ENTITY gamma   "&#x3B3;">
   <!ENTITY epsilon "&#x3B5;">
   <!ENTITY Delta   "&#x394;">
   <!ENTITY delta   "&#x3B4;">
   <!ENTITY SuchThat "&#x220B;">
   <!ENTITY ForAll  "&#x2200;">
   <!ENTITY Element "&#x2208;">
   <!ENTITY Exists  "&#x2203;">
   <!ENTITY Therefore     "&#x2234;">
   <!ENTITY ApplyFunction "&#x2061;">
   <!ENTITY geq     "&#x2265;">
   <!ENTITY leq     "&#x2264;">
   <!ENTITY lfloor  "&#x230A;">
   <!ENTITY rfloor  "&#x230B;">
   <!ENTITY prime   "&#x2032;">
   <!ENTITY isin    "&#x2208;">
   <!ENTITY notin   "&#x2209;">
   <!ENTITY real    "&#x211D;"> ]>
<?php endif; ?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:math="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>Actors and Continuous Functionals</title>
  </head>
  <body>
    <h1 name="title">Actors and Continuous Functionals</h1>
    <h2 name="authors"><span name="1">Carl Hewitt</span> and <span name="2">Henry Baker, Jr.</span></h2>
    <h2 name="organization">Massachusetts Institute of Technology</h2>
    <h2 name="organization">Laboratory for Computer Science</h2>
    <h2 name="publication/date">December 1977</h2>

    <p name="funding">This research was supported by the Advanced Research Projects Agency of the Department of Defense and was monitored by the Office of Naval Research under contract no. N00014-75-C-0522.</p>

    <h3>Section I &mdash; Abstract</h3>

    <p>This paper presents precise versions of some "1aws" that must be satisfied by computations involving communicating parallel processes. The laws take the form of stating plaulible restrtions on the histories of computations that are physically realizable. The laws are very general in that they are obeyed by parallel processes executing on a time varying number of distibued physical processors. For example. some of the proessors might be in orbiting satellites. The laws are justified by appealling to physical intuition and are to be regarded as falsifiable asserions about the kinds of computations that occur in nature rather than as proved theorems in mathematics. The laws are intended to be used to analyze the mechanisms by which multiple processes can communicate to work effectively together to solve difficult problems.</p>

    <p>The laws presented in this paper are intended to be applied to the design and analysis of systems consisting of large numbers of physical processors. The development of such systems is becoming economical because of rapid progress in the development of large integrated circuits.</p>

    <p>We generalize the usual notion of the history of computation as a sequence of events to the notion of a partial order of events. Partial orders of events seem better suited to expressing the causality involved in parallel computations than totally ordered sequences of events obtained by "considering all shuffles" of the elementary steps of the various parallel processes. [<a title="A Semantic Model for Parallel Systems with Scheduling">21</a>,<a title="Processes: A Mathematical Model of Computing Agents">22</a>] The utility of partial orders is demonstrated by using them to express our laws for distributed computation. These laws in turn can be used to prove the usual induction rules for proving properttes of procedures. They can also be used to derive continuity criterion for graphs of functions studied in the Scott-Strachey model of computation. The graph of a function is simply the set of all input output pairs for the function. We can prove that the graph of any physically realizable procedure, <em>&rho;</em>, that behaves like a mathematical function is the limit of a continuous functional <em>F</em> such that:</p>

    <math xmlns="&mathml;">
      <mo>graph</mo><mfenced><mi>&rho;</mi></mfenced>
      <mo>=</mo>
      <msub><mo>&Union;</mo><mrow><mi>i</mi><mo>&Element;</mo><mi>&#x2115;</mi></mrow></msub>
      <msup><mo>F</mo><mi>i</mi></msup><mfenced><mfenced open="{" close="}"></mfenced></mfenced>
    </math>

    <p>In other words the graph of <em>&rho;</em> is the limit of the n-fold compositions of <em>F</em> with itself beginning with the empty graph.</p>

    <h3>Section II &mdash; Introduction</h3>

    <p>In programming languages such as SIMULA-67, [<a title="Simula Begin">17</a>] SMALLTALK, [<a title="Personal Dynamic Media">18</a>] and CLU, [<a title="An Introduction to CLU">20</a>] the emphasis has changed (compared to Algol-60) from that of procedures acting on passive data to that of active data processing messages. The actor model is a formalization of these ideas that is independent of any particular programming language. Instances of SIMULA and SMALLTALK classes and CLU clusters are actors. However, actors have been designed to include the added effects of parallelism so that instances of monitors (42), envelopesH9), and serializers[M} are also actors. The actor" message passing theory can be used to model networks of communicating processes which may be as close together as on the same LSI chip or as far apart as on different planets. It can be used to model processes which communicate .via .haredmemoq(l21 packet-switched networks[l9,2"1 ring-networks[23]. boolean n-cube oetworks[....). or Satcher sorting nets£251</p>

    <h3>Section III &mdash; Actors and Events</h3>

    <p>The theory presented in this part attempts to eharaeterlle the behavior of procedural objects called actors (active objects) in parallel processing systems. Acton and events are tbe fundamental concepn in "the theory. Actors interact with each oth~ through one ae.tor --,inC a mlueoeer. to another actor called the target. The arriyal of a messenger at a ta...- is an event, and these events are the basic steps' in this model of computation. A key point in the actor model of compucat. . is that messencers .3 re themselves actors. The actor model is therefore an up-txped theorywhkh is a generalization of the 1..-cakulus of Church. Actors can be created by another actor as part of the second aetOr's behavior. lndeed, almost every messenger is newly created before being sent to a target actor. Events mark the steps in actor computations; they are the fundamental interactions of actor theory." Each eVttl1t is instantaneous and indiVisible taking no duration "in time. Every event E consists of the arrival of a messenger actor, called ......nl...(£). ata !!!1!1. actor. caW '-1"(£). We will often use the notation:
E: [T

<- M]

to indicate that E has messenger M and. target T. The time of an event is the arrival of the messenger of the event rather than the sending of the messenger because a messenger cannot affect thebehaylor ()f alKld'ter actOr until that actor receives it. If the sender wishes a reply, an actor (caUed the coat.........) to·..... any reply should be sent should also be carried by (as a component of) the messenger. Intuitively. the arrival of the "":ssenger M at the target T maka M's information available to the target

ACTORS'

Hewitt Ilftd 8....

2

for the purpose of activating additional events. Thearrinl of M at T does not in itself cause any change t() either Mar T. For each event E we define ecqAifttencetE(T) and .......1nC. .E(M) to be the vector of immediate acquaintances of T and M, respectively. The immediate aapta,Ultanca of an actor x are the other actors x directly "knows about" at a given instant. 'Therelatlon asymmetric in the sense that it is possible for an actor x to know about'an actor., without it being the cue that., knows about lL An actor mayor may not "know abou~" itself; if it does, it can directl, tend illelf messages!

.1

Law of Finite Acgulintance.: For'" ector. xendeve.E_.- that x thevect9r ecquaintencftE(x) h. finit.'1eft&th.

Ie"" 1"181 or .......nl.r of E,

The above law states that an object can onIYbedi~l, COO,neeted lOrinltel, many other~jects. All of the actors which are definable within, thtHa~a Calculus of' c'hurchh.~e the property, that their acquaintances cannot change withUme; i.e. if x isdef'itted by alan.c.a. ",pre$liOn, then for all evenu ,Eland E2 in which x Is the target or messenger, itWiU be the Cale that '
ecqUlint~1 (x) .1C~utirlt--E2(x)

In order to 'implement interprocess c~unication between parallel processors It is necessary to use actors whose vector of acquatntances changes over time. The PurpoM of' this paper Is toaxlomatize the fundamental laws which govern, the behavior of aucha,an-, An important example of ,an acto~ whose immediate acquaintancesc~angewith time is a cell. A cell is an actor which at 'any given time has exactly oneimmedlate acqualntane:e--jU contents. When the cell is sent a messenger which consists of the mmge, ",.,hat is yaurconttnts?", 1I11d;a enUn...tioll--another actor which will receive theC90tents--the cell is gU,ara"teed to deliV,erlts conter)lSto tha~ 'contin'uation (while also continuing to remember them). AU thismicht be very bortAg if theqxttents of the cell were constant. However, upon arriv,al of a messenger which has the meuage "update your contents to be x· and a continuation, the cell is guaranteed to updatf,lts'cOntentstobe the actor x (whatever that may be) and infOrm the continuation that the update has been performed. The b,!havior of cells will be aXlomatizt'd later in this paper after we have presented enough of the ~tor model to' make this
po~sible.

The targeUE) and the menenler(E) and their immediate acquaintances will be called, (immediate) participants of an event E. The immediate participantsof' an event are exactly those actors which can be accessed without sending any messages.

Finite Interaction Law: For .ech .vent E. the immediat. p..ticipants in E •• finit•.

The above law, which is intended to capture the physical intuition that only finitely many objects can interact in a. single event, is an immediate corollary of the Law of Fi,.iteAcqualntances.

ACTORS
SECTION IV

Hewitt InCI BIMr

a

PABTIALOBDBBINGS on BVENTS

In order to develop a useful model of parallel computation. we have found it desirable to generalize the usual notion of the history of a computation as a sequence of events. In this paper a history of a computation will be expressed as apvUal !"fer whjch,r~clsthe causal and incidental relations between events. The partial orders constrain the maximum amount of parallelism that can be used in an implementation. Any two events which are unordered can be executed concurrently using separate processors. However, there is no reqUirement that an implementation do this. Events can be executed in any time sequence that is consistent with the, partial order.

IV.I ---

AOTIVA.TION OBDJlRING

One important strict partial. orderingQn events in the hjstory ofa computation ls derived from how ev('nts activate one another. Suppose an actor Xl receives a"""'ger "'I in an event El and as a result sends a messenger m2 to another actor x2.Thentbe event E2' which is the arrival of the messenger m2 at x2.is said to be activated by El' Wecal1the tr " .closUre of ttl.s ·acUv.tes· relation the activat.ioll C!fderilll and if .El pr~.£a in th ttJen,we write:

In general -ar.I-) is only a partial ordering because an eventE 'might activate several distinct events E1.·...En. thereby causing a "fork". IV.l.a --- Primitive Actors Labeled sequences are one of the most important kinds of primitive actors. An example of a labeled sequence is [rf"al: 3.,imoR'inary: so) which is a sequence with two acquaintances 3 and. which are labe~ rf'al: 'and imaRinary: respectively. We allow IabeleclseqlJeRCeS with numerical labels to be abbreviated using positional notation so that [I: 3, J: y] c;an be abbreviated Q(3 y). A simple example which illustrates the use of -eci-) isa c:omputation in which integers 3 and 4 are added to produce '7.. We suppose the existence ofa primitive ae:tor called + which takes 11'1 pairs of numbers and produces the sum. In this case + rav. a maNnget' of the following form:
[reque..: [3 4], ""'rlo: c)

which specifies that the message in the request is the argument tuple [3 4] and the rep.ly which is the sum should be sent to the continuation c when it has been cOmputed. Thus the history of the computation contains two events:

ACTORS

Hewitt_B....

4

I: a request event with target + and messenger that speclfies the numbers to be added and an actor c to which the sum should be senti .

2: a. reply event with target cand

m~ger thatspecif.

the sum of the numbers.

These two events are related as follows in theaetivation ordering:
[ + <- [,.eq....: [~4], ,.p1r'O: cD

act
V [c < [",.1,: 7)] ......
The activation ordering can be used to define the notAon of a .h"pI!prhBltlye Ictor as follows:
Definition: An Ktor x will benid

I

I .

to be ••impIe1 prIMltiye letor if whl.l..... event El of the form

.ppears in' the history of a comput8tion then there II •.~ ~ E2 ., ...... forM

E2 1 [c <-1,.,.1,.: r]]
such that E1 -n~'-> E2 and there are no events E Il.!'h thf.t E1 -.ca.) E .....) E2. Simple primitive actors . a re one-in one-out procedures.'

Complaint.processing can easily be incorporated intO the scheme. The history that results from divicM(3 0] which attempts to divide 3 by 0 is shown below:
[divide

< [........: [3 OJ,,.p1r'« ell ......

act
V [c < [eom,l.uu: [.........'UUr. 3))] ......
will not say anything more about the matter.

I

I

Since complaint processing does not have any profound implicationS for the results in .

thispaper~

we

.

1: Lat.r in this paper w. will . . . .xamples of primitive lIdors tueh • simpl•.

- - - - - - - - - - - - - - - - - - - - - - - - - ---_._-----

fork Mel join primitiv.. which Ire Mt

ACTORS

Hewitt end 8....

5

The history of the computation of fectorill[3] using an iterative implementation of ftlctoritl illustrates how the activation ordering can be used to'i1lustratepraperties ,of control structures: We will suppOse. that hlctorial knows about an actor called Ioopwhkh 11..- cuples "'IM.form (.... product] where the initiali~ex is 3 and the initial prOduct is 1. W nc:etvt5 a tuple [index product). where"'. is not 1, then it sends itself the tuple [(iadH • UCWeK )J. [f.torial < [,.""..".,: [3]. r"plr'o: ......

act

I I

ell

a:

V loop < [r"qll"": [3 1], replr'o: ell ......

I
I

.

act
V
[lOOp < [,."qlle••: [2 3]~ replr'o: ......

I'
I

.

ell.

act
V

I: lOop <...... [,.,.qlle.,: [1 6], ,..,,1""'0: ell I
act
V

I

. I: c <-- [rf'ply: 6]]
The actor loop is iterative because it onlyrecau"ira the amount ofworkingltore2 needed to store the index and prodUct. Note that only 2!!!. replyts tent to the ~ c ev.. lhouch c appears as Ihe continuation in several request events, .

IV.I.b --- Laws for the Ac:tivaUon0r4erinc
It is not possible for there to be an infinite number of ev_ts in a chainS of activation betwee't two given events in the activation ordering of tbehii&lDryol a:.......... This law Implies' the nistenee of primitive actors. Stated more formally, Law of Finite Activ.tion CIMini between two Eyentta If Cit ............. In .... ectivltion orderina ....... £1 to £2' then C i, finite.

. 2: The ureful tre.tment of the ,torlle r....red forthit ........ """ In [21].
.

3: A cha in is a tota lIy ordered sequence of events

ACTORS

"'.1" end 8 ....

8

The law of finite activation chains between events 'Is In,tended to express the fact that "Zeno machines"--i.e. machines which compute Infinitely fast-cannot be physl~lIy constructed. For example. consider a computer with your favorite. instruet.tansetwhkh Recutes its first instruction in I microsecond. its second in 1/2 microsecond. Its third In U'4 microsecond. and so on. Thil) machine not only could compute everything normally computable in las t,,-n 2 mtcroMconds. but could also solve the "halting problem". It could ~o thllby simulating a normal aJmP'Ite.rrunnmg on some input. and if the simulation were still running after 2 mkroseconds,it muld conclude that the simulated machine does not halt on that input. Intuitively each event can directly activate only ~ finite number of other events. The events directly activated by an event E are called Immediate!UCC!SlOrs of E (under the activation ordering -oe,·». The immediate successor set of E in the -aca-) ordertne. wnu,n' e,.>(£).can '. be defined formally: ~. . .'
immedi.te-,ucc_4e,_~(E)• (Ell E -oc'-) El end .,J £2 "uch ..... E -.ea.) £2 ..c,·)El)

Then we have.the folloWing law:

Law of Fir,ite Immediate SUCCftlOrlin ttwActtv"ion grde,;nc: For eI•• event, £, t~ Ht l....di......uce.u..)(E) is finite.
We define immediate predecessors in the activation ordering in a manner similar to that used for immediate successors. We postulate that an event Is either an iniUal eyent, In which case it has no predecessors. or it is activated by a unique predecessor'event .
l ... of Unigue...... of Immediate Pr+!I!!!! in ... Actlvltion OnIerinc: For ell e"" E,t... let ilftlHdl""'ecI-.ca_)(E) .....~ . . . _ ~

This law is based on the physical intuition that two distinct events cannot both be the immediate cause of anoth~r event. This is because an' event whkh immediately aetlvates another event must have been the sender of the m~ssenger for that se<XJnd event Thul each event £ has at most one acHy.tor· which if it exists will b~ denored as ectiYator(E). ' Note ,that the activation ordering analyzes the causality of the classical "fork-join" structure of parallel computations in an asymmetric manner. The reason Is that the last event to arrive at the join is the one which activates the remainder of the computation. Latei- inthiJpaper we will introduce another partial order on events [called the continuation order) whkh treats -fork-jotn" control structures ina symmetriC fashion.

,,--

i: This usage of the t~rm "activator" is somewhat Inconflkt with the usage of the term in Creif and

._-------------------------------

Hewitt[iO). The usage here has the advantage that It Is more firmly Crounded' in the physics of computation.

ACTORS
IV.2 ---

Hewitt end Biller

7

ARRIVAL OBpBBINGS

Intuitively. the activation ordering can be identifi«l with "causality" in which each event is "caused" by its activator. However, the activaUonordering"il not enough ~ specify the actions f')f actors with "side~ffects". such ;liS cells. For this reason, we h1trOd~ the onIeFinc ..,.,..>. for an actor x whose behavior depends on the order of arrival9fthe . . . . . . . . . .t to 'x. The physical basis for defining the order o.f arrival isa hardware devb called arblter. Note that there are only a few primitive actors s.uch as cells an(l synchronillti9n I'rtnltttYe whale behavior actually depends on the order in which me$Sengers arrive. Such ae:toJla"called . . . . . . .t. All other actors are !!!!!!. independent and do not need to use an arb• •1nce they cantlie freely copied to make as many instances as desired.

mi.a,

an

Due to the totality of the order of arrival of messengers at an order dependent actor x (which will be discussed in more detail below), the notion of I "local time" for xu well-defined. Therefore, when talking about jI single actor, we can talk rigoroullyabout the chanps an Ita vector of acquaintances over time.

IV.2.a --- Laws for Arrival Orderings

The arrival ordering for nch order dependent actor • is required to be a total ordering on all eyents which have x as their target. This policy is enfQfCeCi byarbltratiaftin a~ such as synchronization primitives whkh need to obserye the order in which inei_. . arrive. " ,

.

dletr

Arriy.l Order;n, L.w: 'If El..E2 end t-."eEl )8t...e'~)Ia, , then either El ...,.,..). £2 or £2 -e,...,>. £1

This law says that the messenger of £1 arriyes at • before the messenger of arrival ordering is defined by the arbiter for •.

£2

or vice-yersa. The

Note in connection with arriYal orderings that there is no necessary "elation between the a~rivals of two messengers at a target and the ordering of their Ictivator events. Suppose that eyents £1 and E2 have the same targE't •. Then, in general, the drcumetanee thlt [1 .......>. E2 doeS not imply that £1 -nf!'-> E2 since E1 and E2 might be distinct eventi 01 twolsynchronouS processes that both happen to send messengers to the same actor. Furthermore, the fact that ........1) ....-) ectiY8Ior([2) is no guarantee that E1 -or,..). [2; i.e. the masenger of ~ mightltiH arriye at the target actOr before. the messenger of El' Each actor is created at some point in time. This Cact is embodied in the Colletwing law:
L.w of Finite Pre_HSO" in en IIrriY.. ordetinls r or all eyent. E' lEI E -nrr->tarlet(E') E'J is finite.

ACTORS

Hewitt_SlUr

8

Given an event E1 of the form [T (NN Mil and al1' event EZ of' the form[T <- MZ]' there are only a finite numbetof events between these two events in the arrival ordering""'>r. Stated more formally: Coroll.ry: L.w of Finite Chit", between two Eventl in 1ft Amy.. Ord!rin&1 For .11 event. El .ncIEZ_htbat tlr.eU(1) -t...-tCE2)- .. {EI E1 -nrr->. E -orr->. EZ} il finit~. The above law impUesthat anomalous behavior like the following is not physlcaly realizable: a cen r~eives the inHnite sequence of ·store· messages: [RON: 11 £11_ 1/2], [".... 1/4), ["Me: 1/1)' etc. and then receiving a ·contents?· message. What is itto.reply? Zero? Jut pro was never explicitly stored into the cell! . . . The law of Finite Chains in the Arrival Ordering allows us to define immechate predecessors and immediate' successors for the arrival ordering In a manner limilarto the one used for the activation ordering. It guarantee that the arrival ordering for ea~h.etor is"l C)ver iCi domain. successors and predecenors are unique when they e~cllt. •If an ,event E 110 an Imfnediatepfed~r in -orr->t••et'E) then it will be •called. the precureor of E and will be denoted by ".....CE). The law guarantees that the process of repeatedly taking the precursorof' an event with targett wlu rind the creation event (or t in a finite number of steps.

SECTION'V

C:aBATION:of AcToRS

The actor ~essage passing model differs 'rom most other theories of' compu~tion in that it explicitly . deals with the issues .involved in creating new objects. Intuitively the creation of an actor. must precede any use of.. In order to precisely state the above intuition ,u a law we must be more precise about when actors are created. For ea~h actor. which is created in the course of a computation, we shall require that there is •• untque event cr."ion(x) which caused x to be created. . ' Lt't cre.t.d(E) be the set (possibly empty) of actors crated by the event E--I.e. the set of actors which claim E as their creation event. Note that x is not apartklpant increltlon(x) because x does noc come into ex istence until after cre.tionlx) has occurred.

The intuition that a single event can only create finitely many objects is formalized as follows:
L.w of Finite Cre.tions For .... ewnt E, crHtH(£) it finite.

Note that the elements of cre.ted(E) might be mutual acquaintances of one another and that mutually recursi ve procedures can be created in this way.

ACTORS

Hewitt Ind BIMr

9

SECTION VI
VIJ

OBLLS

'Axiom tor O.lla '

The axiom for cells has two patts: involving their creation Ind use which can be stated IS follows: Creation: There is a' simple primitive actor, called cr.lltrcel', such that whenever it is sent a tuple of the form[iJ, it 'crates In aaor I which is a new storage cell with initial contents the actor i. More formally, for each event E1 of the, form £1: [cr....-e.U (...... (MJllcW:[t], ,epl,-,o: cD there is a unique event E20f the form E21 [c (- [reply: such that I is a newly cr9tecl simple primitive actor and E1. ectiYltorCE2)' Furthermore 'cr• .tedCE1) • (Il' which says that the only acter created by the event 11 is the storage cell I. Thus each storage cell that is returned by' c.lI differs from all preViously created cells. T~e storage celli always huexae:tly aIM acquaintance which is initially i. If E is an event which his, as its target we wUl use the notation cont.nt'E(I) to denote this acquaintance atithe time of the event E.

III

eN.

Use: A storage cell I can only be sent messages of the' form [eo",...,,?] which requests the ·current· contents and [.,.r- xl which updates the contenlSto be
, I '

~

!
I ,

The contents of I when it receives one of these menages in an event E can be axiomatiled using the arrival ordering for • u follows: cont.nt'E(s) ;: if E la4. an immeclia'e pfeclece.tor 'n 'ltefll'riwal oN.,.,... lor •
'laen

if precunor(E) U 0'/ 'Iae fo,,,. [I <- [.......c: [.~...: x), replr'o: ...]]
,laf!n x el",. contenuprecursor(E)(I) tll.e i ..,liiela u ,he ae'or Iftn, '0 c....-e.u

'0

creo'. I

,

If E is an event of the form [, (- [......,,: [",",... replr,01 ell then there is' a unique event E' of the form E'. [c <- [,..ply: conIentI£CI)]] such that
E

,.1]

=-etivator(E').

".. ~,., ,

..

,'"

ACTORS

Hewitt 1nd8....
VI.2 -~

10

Bu.,.. W.ltly .

Busy waiting is the kind of waiUngused insotnemulti~proeesslng .ystems. In this kind of watting, the contents of a cell is continually checked and, If It is unchan,ed, the proeeuor branches back to check it again. This kind of waiting Is. used w~eo onepl'OCellOl' ~ .cilIpInd upon another to ·wake it up· when the contents change. Busy wailing depends upon the PftJI*'l7 ofFinJte ,Chai'" between Events In the arrival orderings of cells. . For example suppOse that a new storage cell. is created whole initial concenu are O. Furthermore suppose that the con~ts of s are updated exactly once by a proc:eu whldt $eRds I the messale ['l/uln'*,: 1]. Now another process might bus, . .it unUithe COl'- ,f1I the celie change to 1 by ext"Cuting a procedure of the folloWing form:
loop:

if contents(s)& 0 _n,;, loop ( " . ( I ••• proceed...

'''('ft

The propt"rty of Finite Chains between Events in the arrival ordering for I, guarantees that the code ...proceed... will eventually be ex~uted since otherwise tt•.,. woukJ '" an infinite number or -contents?messages b.efore the Jup4lfa,e: i] message in the arrival ordering of .. The use of the arrival ordering In the actor model ,of computation seems to help overcome one or'the major limitations of other theories of thesemantks of Communicating parallel processes based on the Scott-Strachey model of computation [5,61 The~-Strachey model is a deep mathematical study of functions that are minimal fixed poinfS of -cOntinuous· functionals.. As currently developed the Scott-Strachey model seems to be a spedal case of theadOl' model •. that it.only dais wilh actors which behave like mathematical functions to the exclusion of acton sUch as cells and synchronization primitives whose behavior depends on the arrival ordering of masaees sent to the actor.

S='E=--C.=.T.:.IO;;;;..:..;::N_V..:;..;I=;:I::...-_....L=A.=..;.;W;...::S~o'~LOCA.LITY
We would like to formalilethe physical intuition that compueatlon is local and there can be no -action at a distance". The laws of locality presented in this are inMnded to capture these intuitions.

lett.

The initial acquaintances of an actor are a subset of the participants in its creation event and the actors created by its creation event:
Initiel Acquaintance. Law1 If en actor I is the tarlet of 1ft fteM E such tMt E i. the first .v.... in the arrivel ........ 1 ....... ecqueintenc"E(z) ~ pertic......~ ) ) U ~Cz»

The acquaintances of an actor can increase oyer its previous acquaintances onl, by the acquaintances of the mt's~('ngt"l's which it receives and the actors whkh it crates.

AOTORS

Hewitl end 8....

11

Precursor Acquaintenee. lew: If In Ktor z is the terset of an event E such that E has I precurlOr' In the errival or""", of z then, acquaintenc"E(z)' p~tc""Cprec...-(l»U creltMCprecunor(E» An actor )( can only be the target or messenger in an event E if • is newly (reated or is an immediate participant in ectivltor(E). Activator Acquaintance. law: For oech evont E which is not 1ft initi.. event t.rsoUE) E p....icipant.(activ.tor(E»U cr.~_~» mes.enler(E) E partici,.m.(ecttv.aor(E» U . . . . .. . ,....(E» . These laws of locality can be used a$ the foundatiOn on which to build theories of information flow in computer systems. Using the formalism, ~ theory can be dev..... toshqW how the Imposition of initial constraints can be used to eliminateundeNJ:able information,.th.. In. this way, prot~ion problems. such as the Confinement. Problem may be·IOI:~. The.'- message paSling model can be used as the foundation for formaUsm~ (iuch ~StrongDependenq [ill) (or describing informatiOn tra.nsmissionin computational systems and for proving that .nr....tton b not transmitted over certain paths.

S ;;;;;..E~C.-.T~IO;:;;..::N~V~I=II=--__OO,;.· ~II='=~ O.I!.BBING
To make sen~e out of the activation and arrival orderings. and to re"te them to a.notion of -time-, ~we introduce the precedes relation --->-: Definition: --) is binary relation on events which II the transitive closure of the union of the activation ordering -oe'-) and the arrival orderings ..."..>. for every.~orx. In order for --> to function as a notion of ·precedence. we require that the activation and arrival orderings be consistent. This is guaranteed by the Law of Stnct.·. Causality for actor systems which states that ther. are no cycles allowed in causal chains; i.e. it is never the caM that there is an event E in the history of an actor system which precedes itself. Stated more the law of causality is that the combined ordering is also a strict partial ordering:

a

(OfIlIa.,

law of Strict C~ty:F... no event E . . . E -> E. Suppose that we have events in a computation described as follows:

ACTORS

Hewitt end a..,

12

E1: E2: E3: E4: E1 E2 E3 E4

[x < [y <

m1l m2] [y<"'''' m3] [x < m4] ......

-nr,->E 2 ;arrivel of m1 at x cause. the arriv" of "'2" y
-nrr->y E3 ;m2 arri.ve. It y &Mfor. "'3.

-nr'-> E4 ;arrival of MJ It Ye""e.the amv" of m4 It x -nr,.->x E1 ;m4 arriv" at x before ml

The Law of Strict Causality states that the history of the compu,tation given above is physically impossible to realize even though it Is locally reasonable in ttteaense that any proper subset of the orderings can be realized. The above example of an impossible computation is due to Guy Steele. Now we can define immediate predecessors and successors of an event E under -). Note that an event E of the form I: t < m] has at most tWO Immediate predecessors in the relation --) one of which is the ...... activator of E and the other is the precursor of E in the arrival or~ering -art-)t. We would like to formalize the intuition, that between any two events which are causally related, that there are only finitely many events in a causal chain that connects the events. This intuition is formalized in the following law: ' The Law of Finite Chain. betw.en .vent. in the Combined Orarinc.5 Th~re are no infinite chains of .vent. ~tw.... two.ventl in the .trid ' ....iII orderinl --). Actua lIy we qln express a much stronger property about the activity tha,t can occur between two events: Corollary: Law of Finitely Many Events betwe.n two even" in the Combined Orderinc. For all event E1 and E2 the set (EI El--> E --) E2} is finite. The above law is easily proved using Konig's Infinity Lemma and the law that there are no infinite cha ins between two events. Note that the Law of Finite Chains between two Events in the Activation Ordering and any Arrival Ordering are Immediate corollaries of the above law. The above law has important consequences for models of actor systems. It implies that for each history of a computation that there, exist "time" functions that map eventa onto integers. In general· there are many time functions that correspond to onehlstorywhlch.re ~ned by considering .11 the posSibte total orders that observers ,,!ight see. Such time functions have the following properties:

"

~

..

_-,._-._ _.-._---------'----------_._--_._,- •...•.....,,----_.•...

5: This law is a strict ceneraliution of the other lawl in thiI p.,.r. We oriliMily conjectured that it could be proved using the Laws of Locality tosether with the r"t of the I.... How..... Will Clinl.r (47) found • counterexample. Sub.equently V_dis a.rlins [41] ind,,,"ntly fOUftll • very belUtiful .ymmetric form of the eounh~rexamJDle •• the lolution to a el. . e••reiN in MIT cI.- '''35.

ACTORS

Hewitt Ind B.....

13

VEl E2 VEl E2

if E1 --> E2 'lee" time(Et) <time(£2) if time(Et).time(E2),"elt EI-E2'

We can use the combined ordering ...) to expreSs an important law about created actors. Law of Cre.tion before Use: If an .ctorx i. cre.ted in the creation(x) ••>E

COUI'M

of • computation Iftd E is an event with participant x then

VUI.1 ---

HESTHD AOTIVITIBS

Since one of the aims of actor theory is to studypattems of passing messages, we must identify several common patterns. The t~o most commcm t~ of, rnesaet:II"" are requet.. and replies to requests. A request has two acquaintances: the request message 'itIeIf, ami a continUation actor which is to receive the reply. A reply to a request ,consists of a message Mrtt,tet thecont...".tion; this reply usually contains an answer to the request. but may contain a complaint oracule for why an answer is not forthcoming. We define the 1U!$t~ a(:tivity corresponding to a request eVei1t ROin a computation to be the set of events which follow RQin the combined 'order but p~ any reply RP to the, request. More formally, let E--~ denote the set of events which follow E <_Wing £ itself) and ~E denote the set Of events which precede E (including E) in, the computation. In other words
E-·~
Ii!

--~£ I!

IE' EaE' .,. £ --> £'1 IE'l E-E''.,. E' ...> £l

C.finition: If an event E is of the form [ ... <"'''' [reqtl.at: ..., Nply-te: cD then any event £' of the forlft I[ C < [rf' ,,1y: ...)] such that E ·.ec-> £' will be s.aid to be a !!I'!JI. toE. ...... We can now define an activity to be a let of events a. follOw.: .ctivity(RQ)
II

RQ••~

n

U{--~RP

I RP I•• reply to RQI

Activities embody the notion of the nesting of activities that is produced by conventional programming since we only include those events in an activity which contribute to a reply to that request. Note that if no reply is ever made to the request RO in the computation. then the aCtivity corresponding to RQ is incomplete and therefore vacuous.
languag~s.

If we let concurrent ectivitie. be those whose request eventl are unordered, then concurrent activities may overlap--i.e. share some events. However, this can only hapl*' if the activities involve some shared actor which is called upon by both; if two concurrent activities involve only ·pure· actors which by definition have no arrival ordering and can be freely copied to avoid arbitration bottlenecks, then activities are properly nested, meaning that two activities are either disjoint, or one is a subset of the other.

ACTORS

Hewitt Ind 8....

14

The notion ofacti vities a1I0ws one to vary the level of detail in using actors to model a real system. Let us define a primitive activity as the activity of a request whichaetivates exactly one immediate reply. with no events intervening. Thus. a primitive activity always consists of exactly two events. A crude model for a system might represent an actor as priMitive, i.e. one whose receipt events are all primitive. However. at a finer level of detail. one might model the internal working. fIf the actor as an activity in which a group of "sub"-actors participate.

SECTIO N~I=X==--_-.-.:::O:..:::O:..:::N:.:.:T:.:I::::.N.::..;:U:;.;::A:::.T:.:I::.;:O:;.;::N~O:;.;::B=D;:::;.=E=B=I.:.:N:.=..G
The notion of nested activities can be used to help explicate several of the various notions of "process" that have been used in computer ,science. In particular it~n beu~ to define an ordering on events that is important to defining the semanUC$ of programming languagn for parallel processing. This new ordering is the continuation' order and ,will be denoceet,by -e.n'~>, The (Of1tinuat~on ordering is important beeaus, it captur~ the usual operating syStem ,pottonof ·PrOcess" in terms of partial orders on events. Later in this paper we will show how to ,use the CORdnuation ordering to provide a precise cha racterizatjcm of the relationship ~the Scou-$trachey nMxtei and the actor message-passing model. . . ,
Cefinition: If E and E' are events then E -con'-) E' if 1: There is some activity Clr luch that E, E' • Clr and

2: E --> E'

Note that each event has only finitely many predecessors and finitely many immediate successors in the continuation ordering because -con,-) is a sub-ordering of --).

IX.I --- Fork-Join Behavior
In programming languages for parailel processing. it is'quite common to proVide primitives by which processing can "fork" creating more parallelism which can later join together. Parallel evaluation or the arguments of a procedure prOVides a good example of fork-join behavior. All fork-join primitives have b~sical~ the same structure. Consider for example. the behavior of a procedure f which computes (1(2 + y ) given arguments x and y. Below are the two possible hiltories for an activity of f which produces these results where --> is used for the combined ordering:

ACTORS

Hewitt end Beker

15

£1: [f <",,,, [reql&e,.: [x y], replr'o: c]]

----------act-~------£2:

1 1

V I: * < [r""u,..': [x x], rtlplr'o: cl]] ........ I.
act I

1

--------act-----------I
'I

V

£3' [ . <- [reer-.": [y y], replr'o: c2)]

V

act 1

V

£4: I[ c l < [rtlply:x 2 )] .......

ESI [c2

<- [reply: y2)]

--------------I

I

V £&:

--------act----~--·1

I

V

[+ <","" Creque,,: fx 2 y2], replr'o: c]]

act I
V
£7' [c

I

<..,.., [reply. (x2 + y2)]]

Note that in the history given above that E5 -ee.-) £4 -,u·,-) £6'

Ee

whereas in the history given below that

£1: [f (","" [roqu4'•• :tx y], replrao: c]]

£2: I[

* <........ [re'1u".': [xx), replr'o: clll
1 act

I V

----------act--------- , --------act----------I
E3 1
[.

1

I

V

<- [requ.,,: [y y), replr'o: c2]] I act

I V
£4:

I V
£5' [c2

I: c 1 <...."" [reply: x 2 ]] I

<..,.., (reply: y2])

-----act------

£6: [+ .<....... [reql&4'.I: [x2 y2], replr1o: e]]

I V

I V

---------------~---

I

V £7: [c <~.., [reply. (x 2 + y2»))

I act I

ACTORS

Hewitt Ind BIMr

18

We shall say that £1 is a fork event and that Et is a pin event. In the above computation it will necessarily be the case that'£t -oe.-) Es since this is the only way thaC EI can be activated. Therefore it will be the case that either £4 -oea-) £& or Es -oC'-> It. The contInUatton orcIertn, enables us to present the history of the computation without having to. be concerned as to : ':lich of the above possibilities actually occured. Using the. contiftUatton or4erlngtM symmetry of the above fork·joln computation ·is demonstrated. by the fact that the conttnuatton ordering is the same for both of the above histories:

-eo,,'-)

£1: [f

<- [reque": [x y], replr' O: cD

-----·-----co·nt-------- --------cont---------£2:

I

I

I: * < [reque••: [x xl, repi.r'o: ctD ...... I
. cont

V

I

V
E,I [. <- [Nq....: [y y], r.ply-.o: c2Jl

I

cont

I

E4:

I: c 1 <...... [r"I,I y: x 2]] I
----cont------

I V

I V
£5: [c2 <- [reply: y2]]

. I

-------cont--------

I V
£6: [+

I V
<..,.., [reque..: [x2 y2], replrUJ: cD

cant·
V
£7: [c

I I

<..,.., [reply: (x2 + y2))]

IX.2 ---

Synchronization Betw..n Prooesse.

The behavior of semaphores provides a simple example to illustrate the relationship ·between the activation and continuation orderings. Suppose that. is a newly created semaphore whose capacity (count) is initially 0 so that the first attefN»t to perform a P operation will wait until a V operation is performed on the semaphore. In order to model the behavlorof ..-phores "sing message passing. we [P:] and [V:] requests resPectively. will suppose that P and V operations are implemented by Suppose that Ep is the first event in the arrival orcieringof • in which. receives a (P:] request and Ey is the next event in which. receives a [V:] request. The aetiqtiOn and continuation relations between these events is shown below:

send.,

ACTORS

Hewittlftd B....

17

Ep : [ . <..,.., [r"qUft": [P:], ntply-'O: cll]

I
cont

V
E: I[el <..,..,
~r.,ply: ...]]

I

<-act-

£Va [.

<- [......at: [V:), reply-'.: cz]]

cant
V
[cz <- [reply: ~..]]
Note that Ey --> E since Ey -ae'-) E but it is not the case that E., -e."'-) E because there is no activity in which they are both elements. . .

I

I

SEOTION X
X.I

.,- PBOOBDURBS

m

Behavior 01 Prooedures

In this section we would like to characterize the behaviors of acton which behave like procedures. In order to do this we would like to use the notion of an ac:tiylty. . To make our discussion more concrete we 1!YUI Fibonacci function defined as follows:
(fib n)
(if
(n (n (n
ii

~

the behavtor of an implementation of the

= 1) I/um 1
II

2)

,h~n

1

> 2) ,hfOn ((fib (n - 1» + (fib (n - 2»»

The folloWing history is a partial order of some of the events that might reauk from evaluating (fib 4).

ACTORS

Hewl" 1nd8....

18

I I ' ' V
E2 : [fib

----------cont--~---~- --~~---~cont----~-----

,v
£3' [fib (.., lnr9u": [2], reply-'o: cz]]

I I

< ......

[rf?,,"6": [3], replr'o: ell]

cant

I

cont

I

I V
E4: [cl (...... [rf?ply: 2]]

----cont------

I I

---~--cont---------'

I V E,I .[CZ <.., [reply: 1D 'I. . I

I I VV

Ee'

[+ < N·[rwq..": [2 1], "''''r'e: cD ...

cont
V
E7:

I

I

[e <NOlI [reply: 3]]

We will lise the notation {I(p <= m) --) YI~ to partially describe an' activity which starts with an event of the form [p (NN [rp.""p.,,: m, .rffp1r'o: e]] and finishes with an event of the form [e <- [rftply: y)]. of the events shown in the above diagram are contained in one .dAvity (which we win name of fib whose starting event is E1 and whose finllhing event is E7; Thus the activity .. il of the form {I(fib (a [4]) --) 31J. The diagram above shows two IUb-attiyittel of .. -which we will call II and " such that the following relationships hokt

An

.>

fJ:

or:

(J(fib (I(fib

<= 3) --) 21} <= 2) --) 11}

......(6). E2
......(-y). £3
Ih~wn

finilh(/J) • E4 finilh(,,) • £5

The activity {:J has events which are not in the diagram below:

in the above diagram. Some of these events are shown

ACTORS

Hewitt_a....

18

E2 [fib '

< [req....: [3], N"Ir-1O: cl]] ......

I I v I

----------cont-------~

I I

--------cont---------I
V
Egs [fib ( - [.....e": [1), replr'o: c4]]

I I

I
I

E8 : [fib (...", [rpquft.': [2], replr'o: c3]]

cant I V
E 10 : [c3 ("'''' [rnply: 1]]

cont

V
Eit' [c4 ( - [reply: 1]]

I
I I

------cont----

I I

---------cont-----"-

I I V
cant
V

I I V I I

E12: [+ (...... (requIC: [l 1].

N"lr'O: cl]]

E4: I C 1 (...... [rf9ply: 2]]

Thus we see that IJ in turn has sub-activities .,' and' such that

"y': {IUib <= [2]) --) 11} '": {IUib (= [1]) --) 11}

,t.rtC.,') • E. .t....e.'). Eg

finish«.,') • E10 fi~'). Ell

Notice th~t both., and .,' both satisfy the partial dacrtptlon{le. . <- [2]) -> 111 even though they are distinct activities which share no events in common. Uniquely id..ti(ylng activities has the same problems as uniquely identifying ob jectI and .ventl: no finite kal delcrlptlon wiU serve al a unique identification.

;

.,

-·--------~--:-:7'7::_._:

ACTORS
' .

Hewitt nil..,

80
.

An actor' f will be said to behaveolUc.e a procedare if the following coridittonJ hold fOr aU the hlltorlel
~t'

.

.

[ ... <- [rftq~.,:'"'' ,..pl,..,o: •.,U or of' the' form 1- (- [","',:1l.'
2: IrE

1: . All

of

'Mm......" '

of·"""
_

·.In

the

hIitory ••

........of

the

forM

· event.E' In which c Is the ~rget Of. I.and such anE' ~be a

I,. '.....tof the fonn [

<-[......,,:..., .rte: cD. there

rep" to E..

there Is at most

c:*Ie

· 3: The IICtlYitl., of t·.... prop4tf1y ...... I.E. ~,...,·two~ of t Itla ... UN tMt ttlthe, one ,."vity .... ,.,..,.'tubMt 01 the other or ...... ...,..... we .6joW.
An .actor ~ wlh procedure. '

be

said to behave .like a f ••d_if It il order Independent ar4d be"'Yei like a .

X.2 --- Llml~s of Co.tiD...... P!!JUitloaal!.
i . . ,.

. . The actor model of computation is based on axlomatbing the caual and Incidental relations among computational events, The ScQtt-Strac;hey modet of ~ IfbaMd on.~he ~lhematkal an• .,,,ls of continuous tunetton spaces, Superficially t~two ~mJIItt ..... tohaye 1fttIe .n In thiS $ectlon w~ will an~IYH the relattonshtp ~J"""'."'vl c:omputatIoft. ()ur main resUlt is that if an actor be~aves like a mathemlltkalfundlan .... 'tt II the lIInItof a cunUn.,. functlorial In the' sense ofSc()tt.. This rau. fOnoWs tIM II. that each " _ ..., 'In~ man, •.....fdlate successors:. In the contlnuatlon.orderlngand thela. Of' bet. . . riro eYenb lri' the . continuation otddlng. .

common.

r.-.

Once again wt will make the d~S$~concreteby CQnIkIerlng the behavior ~ an tmplemetttatlOn of the Fibonacci (tlllctt.on d~lned~J th~'folloWlng procedure:
(fib n) :: (if (n

(n::; 2)'

='1) '''tln 1 '''ttfl 1

. (n ) 2) ."r.n ((fIb'" -1) + (flb(n - 2»)))

D.finition: Suppos• •n actor.f beha¥es Iik 1Mtic.. fvndIoft and ..... ex y>41"iph(f)" <x' y~,,"'.f). Then <x' y~wm be· saki to "' en f".n Or y> If . ther. I, history of f .~ E r of 1M ....... · . E: [f < [r.q : x, ,..ply-to: U E'f [f < -(reqtl : x', reply-'o: .;.J] . . such. t".t E -ael-) E" . end It is not ttill c tMt there II en .vent E of forM E: [I < .., [req~.,:· ..., r.pl,..,o:· ~.U

,he

.~h 'h8t E .:.eo",-> E -caR'-)~'

.

ACTORS

Hewitt and 81ker

21

For example <2 1> is an immediate fib-descendant of <32>. Definition: Suppose thet <x y>ElraphCf) immediete-delcendantlfC<x y» • l<x' y'>l <w,' y'> ilift h"",.diate f. . . .ndMt Of <x y>} 1» immed.i,ate-descendantlfibC<2 1» immediate-delcendant'fibC<3 ,2» • {<II> <2 I>} immediate~lcendentlfibC<5 5» .1<3,2> <4 3>} Lemme: If ~n actor f behaves immediate-delcendantsfC<x y» is finite. like a mathematical
fun~lon
immediete-des~end.ntlfibC<l

=() =()

and

<x y>Elr.phCf)

then

Proof: Follows from the Law of Finiteliy Many Im~SitCc:euOr'lntbeAcUvation Ordering. Definition: If G is a let of input-output pel,. the" OfCG) ;: (<x y>1 <x y>flnphCf) Mel ~. . . . . . . . . .fC<x y»
~

O}

Intuitively Df(G) is the set or all Input-output pairs of .",CI) that can be computed ·immediately· from thl" inpur-olltput pairs in O. For example ~' han thefoUowing .....1tI for our implementation of the fibonacci function DfibC{}> {<I I> '<2 I>} Dfib C{<l 1> <2, I>}) {<I I> <2 I> <3 2>} 0fibC{<l 1> <2 1> <0 4>}) {<I 1> <2 1> <3 2>} Dfib C{<3 2> <4 3>}) • {<I 1> <21> <55>}

=

=

=

Lemme: If an actor f behaves like a mathematicalfunetion. then Df is a continuous functional. Proof: From its definition Of is clearly monotonic. We will use N to denote the natural numbers (j.e. the non-npgative intpgers]. Suppose that (Xii ifNI Is a chain of sets of ordered pain 10 that Xi ~ Xi +l' To prove that Of is continuous we shall prove that

Clearly

by the monotonicity of Of. To prove the set inclusion the other way around suppose

It follo~s from the definition of Of that <x,y>flraphCf) and

ACTORS

Hewitt Ind BiMr

22

The.refore there exists a natural number n such that immecli.d....ndaftt.fC<x.y» s; Xn since the immediate f-descendants of <x.y> are finite.· Thus <x,y>fo,CXn) and

Definition: A sequence <Xi Yi)such that each <xi YI~,r.lPhCf) wtll be said to be a descending f-chain if each <xi+1 Yi+1) is an immediate f-descendant of <xt't>. Eump'e: The following are descending fib-chains [<6 8> <4 3> <3 2> <1 1>] [<7 13> <5 5> <3 2.) <2 1>] lemm8: If <x y>flr.ph(f) then there are only finitely many descending f-chains begining with <x y>. Proof: Follows from the fact that there ~re only finitely' many events between two events of the.form I[ f<...... [rf''1 f1 x. rp/,lr'D: ell and [e <",;;, [r."',: yO in the continuatien ordering.

p..,:

Cefinition: If <x y>Ear.ph(f) then hei,htCf.<x y»will be defmed as the maximum length of the descending f-chains beginning with <x y>. . . . lemm8: If <x y>flnph(f) then <x y>f0fhei,hUf.<X y»({U where 0fn is the n-fold composiUon of Df with itself. Theorem: If an actor f behaves like a mathematical funaion then Df is a continuous functional in the s~nse of Scott and ,r.h(f) is the limit of Of beginning with the empty graph i.e.

n

Ir.,tt(f) • ~N Ofi({U where Iraph(f) is the set of input-output pairs of f. It immediately follows that ,raph(t) is the minimal fixed point of Of since

The above theorem makes precise the physical basis for belieVing that the graph of every physically fE'a'izable mathE'matical function is the limit of a continuous functional: the Law of Finitely Many Immediate Successors and the Law of Finite Chains between two Events in the Continuation Ordering. As currently developed the Scott-Strachey theory does not account for the the properties of the arrival orderings of actors such as synchronization primitives and shared data bases. An interesting topic that is left open for future research is how th, Scott-Straehey theory can be extended in a natural way to encompass the physical constraints imposed· by the arrival orderings of actors.

ACTORS

Hewitt end 8. .

23

SECTION XI -- PUTU•• WORK
When we first began our investigation intomeuace-:....ng system we developed the intuitively app~aling idea of "actors" as agents which communicate bf pas.tt"messag•. ,This intuitive notiOn proved to be too naive a basis for precise technical WQrk.,1n the JaJIlit .,.that the intuitive notion of • "set" as a collection of objects proved to be too naive . . . . . In mat. . . .tics. The $OIu~ion has been the development of the axioms in this paper which aremtleftded to aeneas tbe first step in developing axioms which capture the intuttive notion of acton as -Cents whkh communicate by sending and receiving messages. There remains a great" deal of work to be done tn the developlnent of the theory presented in this paper. The "completeness" of the axioms ~nted here needs to be tntensive1y studied to determine if they can be significantly strengthened. A mathematical characterization of the models whkhsatisfythe axioms n~sto be, developed. The characterization should include a descrtption of a ~t1da(Clmodel ~ by ~ constructive method for enumerating all the computation histories of a system thatJaUlfY the a.tomstn this paper. Eliot Moss and Henry Baker [50] have developed one suchmocie1 whteh ""eveltheJx"l~stency the ·axi~s in this paper as well as prOViding a stllndard mocieltn whiehthe a.iOfRI~.. be interpreted.

of

We would like to apply the semantic theory develQped. tn· this paper in several directions. The semantics of programming languages for mUlti-proc:f!IIInc prob1emlOlvJng languages such as KRL, OWL, PLASMA, SIMULA, SMALI;.TALK,AWORD. and the ...tatif~tIOnal~lculus need to ~ rigorously developed. In this way we hope to be able to make ,...... technical contributions to the "df'elarative-prOCedural" controversy. There are a number of q~estions concerned with how effktently actor systems can be implemented on networks of machines. In terms of the physicaltra~ or jnf~tkM1 there are several ways in which an event can beimpiemented. The information in the ~can be physically transported to the target; the target can be transported to the ~Ier. or the tWo can rendezvous at some other location. Under differing circumstances anyone of the above pouibIUtles might be more efficient. For example if the target is a small functionwhichtnak. use ~ alaraenumber of the extended acquaintances of the messenger then it is p~blymote tf'fkilfttto transport the t~f'get to the messenger. On the other hand if the target is a larpdata base Wltte"ls ~~hed according to the directions of a small query in the messenger, then it is ,,......,, ~ efficient totran~rt the messenger to the target.' Research is needed codevelop dyna~k inlChanismsfor decic:Ung. what information to transport for computations that are phpiC:ally et...,..... on a network of machines. Hopefully some general mechanisms can be developed Whida.tn ,..... J*eId aceeptab~ efficiency.

· ,.:.

ACTORS

24

sB=-O T:;.;:I: ;",; ; O.....__:X~·=II__._-_~ ~ __ N

O....... ON.2LPIION

In this paper we have presented lOme laws that mult be obeytd by the COI'npUtatlons of communicating parallel processes. Theaelaws are expre~ in.the .......pof first ....r set theory. The actor message passing model is based on aXlomatill", the caual and.nc~' rela.tlona between computational ev'ents where each event consbtl of' rtCetvtnc a........ An tmportant~dvantage of the actor message-passing model is that specifications for acton can be expressed directly in terms of the evmts involving those actors. Our approach is different from the more usual one which is to postulate the existence and ·fairness· of, some underlying 'U!!!! -1Chedu1er-',l211 or -C)I"&cle- (221 Partial orders prOVide a means for concentrating on thecau91relatteM amone ..entas opposed to time relationships that result from some arbitrary'interleaving. The dt"velopment of hiJtOries In the actor model of' comptItattcln u panial ,orders of events as a generalization of. the previoUs development as ~,of e\f~b.s proven to be very fruitful. The partial orders -ne,">, -orr->x for'each Ql'der dependent > ••Rd'->. are 'all physica.lly well grounded in the sense that If tlllQevf:fttS.re O;bIen.to tln .•. cet1aln way Insomeobserv~tlon frame then they ,will be ~servedto be ....~ in tht, , 1ft .fI~_tio,R rrameJ.~ch or these different orderings serveSiuow,npur:piose. the ntOdel' The folewtng table summarizes the partial orders which we have introduced toQeseriberhe h...... 01 c:emputltkJns:

in

-etiv"iOn

-nrr->x

-..,,",-)

-->

• rr;vel combined

c-.Hty Iocel U of

..... of
,...

tent to *:
........

......... notten of
neitedtctivlti••

continuation

Partial orders 0'( historie~ have been used to develop specification .nd proof techniques for modular synchronization primitives [S2,SilThe machinery of partial orden of evenU provides the semantic g'llIe needed to relate the specifications arid implementatlonl of' communicating parallel processes. This paper has traced some of the Important relallonahlpl b«ween the actor message-passing model of computation and classical denotational. semantlQ.; It hulMen proved that every .ctorwhlch behaves like a mathematical function b the "mit of a cantinuOIII functtana1. Thai resuk provides a. physical basis for the treatment of continuity in the' SciaU-8trKhey theory of ~utation. ,The .ctor message-passing model has'imponant applications f«the .....UcIof communicating parallel processes which will be explored in subaequent papers.

---~'----

•••

~+

AOTORS
SECTION XIII
AOKNOWL~GEMBNTS

The resea rch reported in ,~his paperwas.sf'O"l()red byiM MIT ~rtlfldaJ Intelligence and Laboratory and the M IT Laboratory for Computer SCience under the aponIOI'Shl, of the Office of Naval Research. A preliminary version of some of the laws In this were presented In an Invited address delivered at the Conference on Petri Nets and Related5y. . . at M.I.T. In Jutyl97&. Some of thenotatl.onfor representing partial orders of events was develapedatthe WorkIhopon Language Features for Non-deterministic Programs whkh was MId In eambrkil" Wa.. *,.Auplt 19'7$. This paper is a slight revision of the one by the lame tatle pmented at the Ifl' WorklnJ Conference on Formal Description of Programming ConCepti at St. Andrews. New BruftlWkk in July lfTI.

paper

Our research on actors is an attempt to ~vkle .~. sernantk.wldenlandJnc .ofconstructs for supporting modular progra(Tls that.have been dev~l~p et and operat.ng systems. The original impetus for the r~r~b came from a ~ , J91:l with Alan KayabcMJt the SM ALLTALK. lang~ge whiCh ."he ~. ,~. ·H.:.· ".k)~se· aU . ···computation, QR communicating. objects ~ch of wh~,can::~aveiJM,......of,a,dll#al,~ter. The desjgfl of . SM ALLT ALK bujlt,onth~~"'tnsra~d"""".IMVLA, .....ratton of goal language from me-thod language in PLANNER, tIM Da.tc1 ,....,. thais. [49] and Seymour Papert's "linle person" model ofcomputatton.Weh&veWlWkecttv°.ltructa theDtttlcal model that encompasses the-se ideas in addition to similar abstraetionJwhkhhaY eIDPed "'lambda cakulus languages and for operating systems such U'domalnS of pnbCItonancicapa........

railtmHlcla

mntrol.idiO.

This paper builds directly on the thms research of Irene Greif. Many of the results in this paper are straightforward applicatiO!ls or Slight generaliIatioAI of reavlu In her dissertation. For example our notion of an activity derives from the bra4eted . . of events in her ttMIb. . Weare further indebted to Irene for the suggestion that the arrival 0I'dettnc of an order ~ent actor may be one of the fundame-Iltal differences between the ~etor modelof' computation anelehe Scott-Strachey model. Many of the ideas presented in this paper have emerged in the last three yean in the course of conversations with Irene Gr~if, Robin Milner, Jack Dennis, Jerry Schwarz, Joe Stoy, Richard Weyhrauch, Steve Ward, and Bert Halstead. BJII Ackenillm. Va1dtsBerzins, Henry Lieberman, Ernst Mayr, Eliot Moss, John Mou~riJ, Bruce Schau,andOuy s.eIe made: valUable comments and criticisms which materially improved the pmentation andGDfttent 01 this paper. The arrow notation used for the differentparUal orden Is due to Gary FOIteI.

ACTORS

Hewitt and 8. ., '

28

SECTION XIV --- BIBLIOGRAPHY
[I] L. Lamport. Time, Clocks and the Ordering Of Events In a Distributed System. CA-7603-29I1, Mass. Computer Assoc., Inc. March 19'76.

Memo

[2] R. W., Floyd. Assigning Meanings to Programs in J.T. Schwattz), Amer. Math. Soc....967.I9-S2.

Mathematisal Aspects of Computer Science
. .

(ed.

[3] C.A.R:'Hoare. An Axiomatic Basis for Computer Programmlnc. CACM 12.10 (Oct. 1969), 576-580.
[4] V. Pratt. Semantical Considerations on Floyd-Hoare LogiC. 17th IEEE Symp. on Founds. of Compo . Sci., Oct, 1976, 109-121.
[5] 0, Scott. Outline of a Mathematical Theory of Computation. •th Princeton CooL on Inf. Sci. and SYI.• 1970. 169-176. .
[6] D.

Scott. The Lattice of Flow Diagrams, Springer- Verlag Le,cture Notes in Mat. 188.1971..

Sxmp.on . Semantics of

Algorithmic Langs.,

[7) J. VUillemin. Correct. aqd. Optin:--I. Irraplementatiorp ~ RfPlnion In ~ Simple Programming Language. J. of Comp.and SIS; Sci. 9., s.Dee, 197i. . [8] R. Lipton. Reduction: A Method of ProVing. Properti4'I of Parallel Programs. CACM 18.12 (Dec. 19'15), '11'1-'121.
[9] S.· OWicki. A Consistent and Complete Deductive Sy. . . for the Verification of Parallel Programs. 8th ACM Symp. Th. Comp.• Hershey. Pa;. May 19'16. ""'. .

[10] R. Rivest and V. Pratt. The Mutual Exclusion Problem for Unreliable Processes. 17th IEEE Symp. on the Founds. of Comp. Sci.• Oct. 1976, 1-8.
[II] E. Organick. The MULTICS System: An ExamtnaUc!n of its Structure. MIT Press. 1972.

[12] W. Wulf. et a1. HYDRA: The kernel of a multiprocessor operating system.. CACM 17.6 (june 1974), 33'1-345.
[13]

J. Dennis and D. P. Misunas. A Preliminary Architecture for a Basic Data-Flow Processor. 2nd IEEE Symp. on Compo Arch.• N.Y.• Jan. 1975. 126-1S2. .

[14] G. Kahn. The Semantics of a Simple Language for Parallel Programming. IFIP-7i. Stockholm, Sweden, North-Holland, 197•.
[15] Hoare. C.A.R. Communicating Sequential Processes

Dept. of Comp. Sci. The Q..ueens of Belfast.

Aug. 1976.

ACTORS

Hewitt and Biker

27

[16] J. Feldman. A Programming Methodology for Distributed 'CompUting (among other things). TR9, Dept. of Compo ScL, U. of Rochester. Feb. 1977. [17] G. Birtwistle. 0.-]. Dahl. B. Myhrhaug. and K. Nygaard. Simula Begin. Auerbach. Phil., Pa., 1973. [18] Learning Research Group. Personal Dynamic Media. SSL76-1. Xerox PARCo Palo Alto, Cal.. April. 1976. . [19] B. Liskov and S. Zilles. Programming with Abstract Data Types. SIGPLAN Notices (April 197"). 50-59.
(20] B. Liskov. An Introduction to CLU. CSG Memo 136. MIT LCS, Feb. 1976.
[~I] E. Cohen. A Semantic Model for Parallel Systems with Scheduling 2nd SIGPLAN-SIGACT Syn'lp. on Prine. of Prog. Langs.• Palo Alto. Cat. Jan. 1975.
(2~]

R. Milner. Processes: A Mathematical Model of Computing Agents. Colloquium in Math. Logic., Bristol. England. North-Holland. '1973. D. J. Farber, et at The Distributed Computing System. 7th IEEE Cornp. Soc. Conf. (COM peON Feb. 197~.~I-~4.

(2~]
7~).

(24] R. Metcalfe and D. Boggs. Ethernet: Distributed Packet SWitching for Local Computer Networks. CSL 75-7. Xerox PARCo Palo Alto, Cal.. Nov. 1975.

(25] K. E. Batcher.
(26]

Sorti~g

Networks and their Applications. 1968 S ICC, April 1968. 307-314.

Hewitt. Viewing Control Structures as Patterns of Passing Messages. WP 92. MIT AI Lab., Dec. 1975. Accepted for publication in the A.I. Journal.

c.

[27] R. Steiger. Actor Machine Architecture M.S. thesis. MIT Dept. [ECS, June 1974.
[28] P. Bishop. Computer Systems with a Very Large Address Space and Garbage Collection. PhD Thesis. M IT Dept. of Elect. Eng. and Compo Sci.• June. 1977.

[29] H. G. Baker. Jr. List Processing in Real Time on a Serial Computer. WP 139, MIT AI Lab.• Feb.

1977, also to appear in CACM. [30] H. Baker and C. Hewitt. The Incremental Garbage Collection SIGART-SIGPLAN Symp.• Rochester. N.Y., Aug. 1977. of Processes. ACM

[31] I. Greif. Semantics of Communicating Parallel Processes. MAC TR-I54. MIT LCS. Sept. 1975. [32] N. Goodman. Coordination of Parallel Processes in the Actor Model of Computation. MIT LCS TR-173, June. 1976.

AOTORS

28

[33] V. Berzins and D. Kapur. Path Expr~lon. In Terms of Events. MIT Specification Croup Working Paper, Dec. 1976.
[~i] C. Hewitt and R. Atkinson. Synchronization in Acwr Sy.... 4th SIQPLAN-SICACT Symp. on Prine. of Prog. Lang., Jan. 1977, 267-280.
.

.

[:,\5] A. Holt, et al. Final Report of the InformatlOnS'- Theon Prolect. RADC-TR-68-305, RADe, . Griffis AFB. N.V., Sept. 1968. '.
[~] F. Furtek .. The Logic of Systems. TR~I70.
[~7]

MIT Lab.Jor eom,. ~i .• Camb" Mass., Dec. 1976. ','

C. Plotkin. A POWerdomain Construttion. SIAM J. Comput. 5.S(Sept. I~), 452-487.

[~8] D. J. Lehmann. Categories for Fixpoint ~Theory ,;, Computation TR ,15, Dept: of Comp~ Sci.. Univ. of Warwick, 1976. .' . . .,
[39] C. Hewitt and H.Baker. Laws (or eomma.n~tinI Parallel. ProCa., IFIP-77. M()ntreal, Aug. 1977. . .
[..0] I. Greif and C. Hewitt. AttorSemantics of PLANNER-?! ACM SIGPLAN-SIGACT Conf., Palo A Ito. Ca 1.. Jan.. 1975.
["I] Hoare, C. A. R. "Mooitors: An Operating Sy~ SUucturinc Concept" CACM. October, 1975.

[42] Hansen, P.B. "Operating System Principia" Prentice-Hall 1t7S.
[4~] Bustard, D. W. "Parallel Programming ,Paxal (PPP)" Version I. Dept. of Computer Science. ~Ieen's University of Belfast. November 19'75. .

[ii] Sullivan. H. and Bashkow T. R.

"A Large Scale. Homogeneous. FUlly Distributed Parallel Machine" Proceedings of Fourth Annual Sympoaum on Computer AKhUecture. March 23':25, 1977. pp 105-117.

[i5] Coht'll. E. S. "Information Transmission in Computational Syacems" The University of Newcastle

upon Tyne Computing Laboratory. June 10,1977.
[i6] Wand. M. "The Frame Model of Computation" Technical Report No. 20. Indiana University Computt'r Science Department. Dec. I, 1974.

[47] Clinger. W. Untitled notes handed ouUn MIT aMIne 6. • in December 1977.
(i8] Berzins. V. "An Independence Resuk for Aaor Laws· Computation Structures CrQUp Note S4.

December 1977;

ACTORS
[19] Fisher. David A. University. May 1970.

Hewitt and Baker

29

"Control Structures for Programming Languages" Phd. Carnegie-Mellon

[50] Baker, Henry G. "Actor Systems for Real-Time Computation" forthcoming Phd. MIT. 1978.

This blank page was inserted to presene pagination.

CS-TR Scanning Project Document Control Form
Report #

Date: ~ J.b I ~5"

Lcs-TB . . 19.!l:

Each of the following should be identified by a checkmark: Originating Department: Artificial Intellegence Laboratory (AI) '){ Laboratory for Computer Science (LCS) Document Type:

o

~

Technical Report (TR)

o

Technical Memo (TM)

o

Other:

Document Information
Originals are:

----------Number of pages:
~

Not to Include DOD forms, prIrUr 1ntsIructIons, etc... origInIII p8Q8S only.

M37.. impG"as)

~ Single-sided or

Intended to be printed as : o Single-sided or

o

Double-sided

Jxl Double-sided
Offset Pr8a

Print type:

o o

TypewrIer InkJet PrIrMr

0

) ( UnkncMn

0 0

~ PrInt
other:. _

Check each if included with document:

~

o o

DODFonn Spine

o
o

Funding Agent Fonn Printers Notes

~

Cover Page Photo negatives

o

Other:

_

Page Data: Blank
Page~,...IlllInbeI):

_

PhotographsITonal Material (br,...........,: Other ("'* --iplial",... number):
Description: Page Number:

_

IlrlKi£ fYlA,(f!

(/<1, )l.\i~).f""O 'Ti-ru;' fAG' d:AGSTBACIJ 1-1' _ _ _.....J(3;:2.- 37) SCNJS9 .JTRoL} Cs>iI£S-"s-fl'l\J£J TP.G'1 ' S (J"")
